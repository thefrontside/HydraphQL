The `@discriminates` directive tells the GraphQL App that an interface
be discriminated by a given value to another interface or a type.
The value by path from `with` argument is used to determine to which
type the interface should be resolved. To more information checkout
how [type resolving](./resolving) works.

```graphql
interface Entity
  @implements(interface: "Node")
  @discriminates(with: "kind") {
    # ...
  }

type Component @implements(interface: "Entity") {
  # ...
}
type Service @implements(interface: "Entity") {
  # ...
}
```

For example if we have a runtime data like this:

```json
{
  "kind": "Component"
  // ...
}
```

The resolvers that are generated by HydraphQL will resolve it to `Component` type.
If for example an interface has only one implementation you can omit `@discriminates`
because resolving is obvious and straightforward.

```graphql
# `Component` type is the only implementation of `Entity` interface
interface Entity @implements(interface: "Node") {
  # ...
}

type Component @implements(interface: "Entity") {
  # ...
}
```

### The `@implements` directive note

You can notice in previous example the [`@implements`](./implements) directive is used.
It's required to use it with `@discriminates` directive. Because it's impossible to
resolve an interface to a type or other interface those don't implement it. In following
example HydraphQL will throw an error.

```graphql
interface Entity
  @implements(interface: "Node")
  @discriminates(with: "kind") {
    # ...
  }

type Component {
  # ...
}
```

### Opaque types

There is a special case when your runtime data doesn't have a value
that can be used to discriminate the interface or there is no type
that matches the value. In this case, you can define `opaqueType` argument.
Think about as a fallback type for cases when impossible to resolve exact type.

```graphql
interface Entity
  @implements(interface: "Node")
  @discriminates(with: "kind", opaqueType: "OpaqueEntity") {
    # ...
  }
```

In this case, if the value of `kind` field doesn't match with any schema type,
the `OpaqueEntity` type will be used. You don't need to define this type,
HydraphQL will generate it for you.

There is another way to define opaque types for all interfaces by using `generateOpaqueTypes`
option. With that option HydraphQL will generate opaque types for all interfaces

```typescript
const application = await createApplication({ generateOpaqueTypes: true });
```

### `@discriminationAlias`

By default value from `with` argument is used to find a type as-is or converted
to PascalCase. And it's fairly enough for most cases. But sometimes you need to
match the value with a type that has a different name. In this case, you can use
`@discriminationAlias` directive.

```graphql
interface API
  @implements(interface: "Node")
  @discriminates(with: "spec.type")
  @discriminationAlias(from: "openapi", to: "OpenAPI") {
    # ...
  }

type OpenAPI @implements(interface: "API") {
  # ...
}
```

This means, when `spec.type` equals to `openapi`, the `API` interface will be
resolved to `OpenAPI` type.

### Using `@discriminates` with multiple data sources

Usally you have a single data source and all your types are resolved according
to runtime data from that source. But sometimes you need to resolve types from
multiple data sources. And more likely data from different sources have different
structure. In this case, you can use `@discriminates(with: "__source")`. So
HydraphQL resolves types according to their source name, which used in `createLoader`

```typescript
const loader = createLoader({
  MyApi: async (queries) => { /* ... */ },
  AnotherApi: async (queries) => { /* ... */ },
});
```

```graphql
extend interface Node
  @discriminates(with: "__source")
  @discriminationAlias(value: "MyApi", type: "MyApiNode")
  @discriminationAlias(value: "AnotherApi", type: "AnotherApiNode") {}

type MyApiNode @implements(interface: "Node") {
  # ...
}

type AnotherApiNode @implements(interface: "Node") {
  # ...
}
```
