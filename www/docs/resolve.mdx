The `@resolve` directive is similar to the [`@field`](./field) directive, but instead of
resolving a field to primitive from the runtime data, it resolves to a GraphQL Node.

### Resolve nodes from runtime data

In following example we have a `Component` type that has a `owner` field.
We tell HydraphQL to take a value of `ownerId` field and resolve it to a `Owner` node
using the same data source used for resolving `Component`.

```graphql
type Component {
  owner: Owner @resolve(at: "ownerId")
}
```

If for resolving `Owner` node we have to use a different data source, we can specify it
using `from` argument:

```graphql
type Component {
  owner: Owner @resolve(at: "ownerId", from: "OwnersAPI")
}
```

### Managing multiple data sources

With multiple data sources you might want to resolve types accroding to the source name.
HydraphQL data loader adds a `__source` field to every node that contains the name of
the data source that was used to resolve the node. You can use this field to
[discriminates](./discriminates) base interface and then resolve to a specific type.

```graphql
extend interface Node
  @discriminates(with: "__source")
  @discriminationAlias(value: "ComponentsAPI", type: "Component")
  @discriminationAlias(value: "OwnersAPI", type: "Owner") {}
```

### Resolving collection of nodes

In some cases a value of a field refers to a collection of nodes. For example, a `Project`
runtime data might have a `spec.projectId` field by which can be resolved a list of tasks
for that project.

```graphql
type Project {
  tasks: [Task!] @resolve(at: "spec.projectId", from: "ExampleCom")
}
```

If there are a lot of nodes in the collection, more than 20, for example, it might be
impropriet to resolve all of them at once. In this case you can use `Connection` interface
for the field type, but you have to describe node type in `nodeType` argument. HydraphQL
will generate a specific connection type for the field and handles type resolving for you.
Check out [collections](./collections) section for more details.

```graphql
type Project {
  tasks: Connection! @resolve(at: "spec.projectId", from: "ExampleCom", nodeType: "Task")
}
```

So the final schema will look like this:

```graphql
type Project {
  tasks(after: String, before: String, first: Int, last: Int): TaskConnection!
}

# These types are generated by HydraphQL
type TaskConnection implements Connection {
  count: Int
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
}

type TaskEdge implements Edge {
  cursor: String!
  node: Task!
}
```

### Resolving nodes from runtime data with arguments

One of the cool features of HydraphQL is that if your data source accepts arguments, you
can pass them with a GraphQL query. For example, if we want to filter tasks by `status`.

```graphql
type Project {
  tasks(status: TaskStatus): Connection @resolve(at: "spec.projectId", from: "ExampleCom", nodeType: "Task")
}
```

### Creating a data loader

To start using `@resolve` directive you need to create a data loader for your API with
`createLoader` function and then make it available in GraphQL context. You can check
out how to do that for [your GraphQL server](./server). If you are interested in how
resolving process works checkout [type resolving](./resolving) section.

```typescript
import querystring from "querystring";
import { createLoader, NodeQuery } from "@frontside/hydraphql";

export const loader = createLoader({
  async ExampleCom(queries: readonly NodeQuery[]) {
    return Promise.all(
      queries.map(async ({ ref, args }) => {
        const response = await fetch(
          `https://example.com/api/${ref}?${querystring.stringify(args)}`,
        );
        return response.json();
      }),
    );
  },
});
```

To understand what's happening here you need to know how [`DataLoader`](https://github.com/graphql/dataloader)
works. Basically, it batches all requests to the same data source and then resolves
them in one go. That's why `ExampleCom` function accepts an array of queries.
Each query has two fields

```typescript
interface NodeQuery {
  ref?: string;
  args?: Record<string, unknown>;
}
```

- `ref` contains a value from runtime data of a field specified in `at` argument of
`@resolve` directive (in our case from above it's a value at `spec.projectId`)
- `args` contains arguments passed to a GraphQL

### Quering data without any references

We can go futher and use `@resolve` directive omitting `at` argument. It opens
a possibility for combinning multiple APIs under one GraphQL endpoint.

```graphql
type Query {
  projects(filter: ProjectsFilter): Connection @resolve(from: "ProjectAPI", nodeType: "Project")
  tasks(filter: TasksFilter): Connection @resolve(from: "TaskAPI", nodeType: "Task")
}
```
