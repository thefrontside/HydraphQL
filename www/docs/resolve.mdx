TODO: Mention `__source` field and link to `@discriminates`
TODO: Link to collections

The `@resolve` directive is similar to the [`@field`](./field) directive, but instead of
resolving a field to primitive from the runtime data, it resolves to a GraphQL Node.
To start using `@resolve` directive you need to create a data loader for your API with
`createLoader` function and then make it available in GraphQL context. You can check
out how to do that for [your GraphQL server](./server). If you are interested in how
resolving process works checkout [type resolving](./resolving) section.

```ts
import querystring from "querystring";
import { createLoader, NodeQuery } from "@frontside/hydraphql";

export const loader = createLoader({
  async ExampleCom(queries: NodeQuery[]) {
    return Promise.all(
      queries.map(async ({ ref, args }) => {
        const response = await fetch(
          `https://example.com/api/${ref}?${querystring.stringify(args)}`,
        );
        return response.json();
      }),
    );
  },
});
```

### Resolve nodes from runtime data

In following example we have a `Component` type that has a `ownerId` field.
We tell HydraphQL to take a value of `ownerId` field and resolve it to a `Owner` node
using the same data source used for resolving `Component`.

```graphql
type Component {
  owner: Owner @resolve(at: "ownerId")
}
```

If for resolving `Owner` node we have to use a different data source, we can specify it
using `from` argument:

```graphql
type Component {
  owner: Owner @resolve(at: "ownerId", from: "OwnersAPI")
}
```

How to add a new data source to your application you can read in [Data Loaders](#data-loaders) section.

1. To achieve that first of all you need to create a DataLoader with `createLoader` function


2. Then you can use the `@resolve` directive with specifying the loader name of your API:

```graphql
type Project {
  tasks: [Task!] @resolve(at: "spec.projectId", from: "ExampleCom")
}
```
